#!/usr/bin/env python3
import sys
import argparse
import pcbnew
import kivar

# TODO create a generic load function that also handles error printing and aborting
# TODO add option to save to a different file (create a copy)
# TODO use escaped variants of aspect and choice when printing!
# TODO use cooked variants of aspect and choice when reading via CLI!
# TODO if output to terminal, use colors for highlighting aspects, choices, matches etc.
#      (provide --no-color/-C option (or a different usual option name))

def version():
    return '0.0.1-dev2'

def list_command(board=None, long=False, detailed=False, selected=False, verbose=False):
    b = pcbnew.LoadBoard(board)
    vardict, errors = kivar.get_vn_dict(b)
    if selected:
        sel = kivar.detect_current_choices(b, vardict)
    ndict = {}
    for ref in vardict:
        for aspect in vardict[ref]:
            if not aspect in ndict:
                ndict[aspect] = {}
            for choice in vardict[ref][aspect]:
                if not choice in ndict[aspect]:
                    ndict[aspect][choice] = {}
                if detailed:
                    ref_info = []
                    ref_value = vardict[ref][aspect][choice][kivar.key_val()]
                    if ref_value is not None:
                        ref_info.append(kivar.escape_string_if_required(ref_value))
                    ref_opts  = vardict[ref][aspect][choice][kivar.key_opts()]
                    if '!' in ref_opts:
                        ref_info.append('<unfit>')
                    ndict[aspect][choice][ref] = ' '.join(ref_info)
    for aspect in sorted(ndict, key=kivar.natural_sort_key):
        if long or detailed:
            print(aspect)
        else:
            print(f'{aspect}:', end='')
        for choice in sorted(ndict[aspect], key=kivar.natural_sort_key):
            if selected and sel[aspect] == choice:
                if long or detailed:
                    print(f'  + {choice}')
                else:
                    print(f' [{choice}]', end='')
            else:
                if long or detailed:
                    print(f'    {choice}')
                else:
                    print(f' {choice}', end='')
            if detailed:
                for ref in sorted(ndict[aspect][choice], key=kivar.natural_sort_key):
                    print(f'        {ref} : {ndict[aspect][choice][ref]}')
        print('')

def state_command(board=None, all=False, verbose=False):
    b = pcbnew.LoadBoard(board)
    vn, errors = kivar.get_vn_dict(b)
    sel = kivar.detect_current_choices(b, vn)
    for aspect in sorted(sel, key=kivar.natural_sort_key):
        choice = sel[aspect]
        if all or choice != '': # TODO use None (in API and here), if None: print ''
            print(f'{aspect}={choice}')

def check_command(board=None, verbose=False):
    b = pcbnew.LoadBoard(board)
    vn, errors = kivar.get_vn_dict(b)
    sel = kivar.detect_current_choices(b, vn)
    failed = []
    for aspect in sorted(sel, key=kivar.natural_sort_key):
        choice = sel[aspect]
        # TODO if verbose: print result of each check here!
        if choice == '': # TODO use None (in API and here), if None: print ''
            failed.append(aspect)
    if len(failed) > 0:
        print(f'Check failed. No matching choice found for {len(failed)} (of {len(sel)}) aspect(s):', file=sys.stderr)
        for aspect in failed:
            print(f'    {aspect}', file=sys.stderr)
        return False
    else:
        print(f'Check succeeded. All {len(sel)} aspect(s) have a matching choice.', file=sys.stderr)
    return True

def set_command(board=None, assign=None, dry_run=False, verify=False, verbose=False):
    # TODO how to handle errors? ignore failing assignments, or abort?
    #      collect errors, then print & return?
    if assign is not None:
        b = pcbnew.LoadBoard(board)
        vn, errors = kivar.get_vn_dict(b)
        sel = kivar.detect_current_choices(b, vn)
        choice_dict = kivar.get_choice_dict(vn)
        for asmt in assign:
            l = kivar.split_raw_str(asmt, '=', False) # test split
            if len(l) == 2:
                aspect = l[0]
                choice = l[1]
                if aspect in sel:
                    if choice in choice_dict[aspect]:
                        sel[aspect] = choice
                    else:
                        print(f'Error: Assignment "{asmt}" failed: No such choice "{choice}" for aspect "{aspect}".')
                else:
                    print(f'Error: Assignment "{asmt}" failed: No such aspect "{aspect}".')
            else:
                print(f'Error: Assignment "{asmt}" failed: Wrong number of "=" separators.')
        report = kivar.apply_choices(b, vn, sel, dry_run)
        if len(report) > 0:
            # performed some changes
            if verify and not dry_run:
                new_sel = kivar.detect_current_choices(b, vn)
                if new_sel != sel:
                    print('Error: Verification failed. Probably caused by ambiguous rules.') # TODO test this!
                    return False
            for ref, change_text in report:
                if dry_run or verbose:
                    print(change_text)
            if not dry_run:
                if pcbnew.SaveBoard(board, b):
                    if verbose:
                        print(f'Board saved to file "{board}".', file=sys.stderr)
                else:
                    print(f'Error: Failed to save board to file "{board}".', file=sys.stderr)
                    return False
        else:
            if verbose or dry_run:
                print('No changes.')
    else:
        print('Error: No assignments passed.')
        return False

    return True

def main():
    parser = argparse.ArgumentParser(description=f"KiVar Command Line Interface ({version()})")
    subparsers = parser.add_subparsers(dest="command")

    list_parser = subparsers.add_parser("list", help="list all available aspects and choices")
    list_parser.add_argument("--selection", "-s", action="store_true", help="mark currently matching choices")
    list_parser.add_argument("--long",      "-l", action="store_true", help="long output style")
    list_parser.add_argument("--detailed",  "-d", action="store_true", help="show component assignments (implies --long)")
    list_parser.add_argument("--verbose",   "-v", action="store_true", help="verbose output")
    list_parser.add_argument("board", help="KiCad PCB file name")

    state_parser = subparsers.add_parser("state", help="show currently matching choice for each aspect")
    state_parser.add_argument("--all",     "-a", action="store_true", help="show all aspects, even without matching choice")
    state_parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    state_parser.add_argument("board", help="KiCad PCB file name")

    check_parser = subparsers.add_parser("check", help="check all aspects for matching choices, exit with error if check fails")
    check_parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    # TODO add option to check only for dedicated list of aspects
    check_parser.add_argument("board", help="KiCad PCB file name")

    set_parser = subparsers.add_parser("set", help="assign choices to aspects")
    set_parser.add_argument("--assign",  "-A", action="append",     help="assign choice to aspect ('str' format: \"aspect=choice\")", metavar="str")
    set_parser.add_argument("--dry-run", "-D", action="store_true", help="only print assignments, do not really perform/save them")
    set_parser.add_argument("--verify",  "-V", action="store_true", help="verify unambiguity of assignments, exit with error if check fails")
    set_parser.add_argument("--verbose", "-v", action="store_true", help="verbose output")
    set_parser.add_argument("board", help="KiCad PCB file name")

    # TODO add command "get": only returns (w/o any human-readable formatting) matching choice name for a given aspect name
    #      (or error if aspect name does not exist, different error code if it exists but has not matching choice).

    args = parser.parse_args()
    result = 0

    if args.command == "list":
        list_command(args.board, args.long, args.detailed, args.selection, args.verbose)
    elif args.command == "state":
        state_command(args.board, args.all, args.verbose)
    elif args.command == "check":
        if not check_command(args.board, args.verbose):
            result = 10
    elif args.command == "set":
        if not set_command(args.board, args.assign, args.dry_run, args.verify, args.verbose):
            result = 11
    else:
        print(f'Missing command. Use "-h" or "--help" for help.', file=sys.stderr)
        result = 2

    return result

if __name__ == "__main__":
    sys.exit(main())
